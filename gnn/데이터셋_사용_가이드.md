# GNN-RAG 데이터 구조 및 ID 매핑 시스템 분석

## 1. 데이터 구조 개요

### 1.1 WebQSP 데이터셋 통계
- **총 엔티티**: 1,441,420개 (Freebase entities)
- **총 관계**: 6,102개 (Freebase relations)
- **Train**: 2,848 questions
- **Test**: 1,639 questions
- **Dev**: 250 questions

### 1.2 데이터 파일 구조

```
data/webqsp/
├── train.json          # 학습 데이터 (질문 + 서브그래프 + 정답)
├── test.json           # 테스트 데이터
├── dev.json            # 검증 데이터
├── entities.txt        # 1,441,420 Freebase MIDs (줄번호 = Global ID)
├── relations.txt       # 6,102 Freebase relations
├── vocab.txt           # 단어 사전
├── word_emb.npy        # 단어 임베딩 (300d)
├── entity_emb_100d.npy # 엔티티 임베딩 (100d, 459MB)
└── relation_emb_100d.npy # 관계 임베딩 (100d)
```

---

## 2. JSON 데이터 구조

### 2.1 Train 데이터 예시

```json
{
    "id": "WebQTrn-0",
    "question": "what is the name of justin bieber brother",
    "entities": [15],  // ← 로컬 ID (질문에 언급된 엔티티)
    "answers": [
        {
            "kb_id": "m.0gxnnwq",     // ← Freebase MID (정답)
            "text": "Jaxon Bieber"
        }
    ],
    "subgraph": {
        "tuples": [
            [0, 0, 1],    // ← [head_local_id, relation_id, tail_local_id]
            [2, 1, 0],    // 모두 로컬 ID 사용
            [3, 2, 4],
            ...
        ],
        "entities": [...]  // 서브그래프에 포함된 엔티티들 (로컬 ID)
    }
}
```

### 2.2 Test 데이터 예시

```json
{
    "id": "WebQTest-0",
    "question": "what does jamaican people speak",
    "entities": [4648],  // ← 로컬 ID (Jamaica)
    "answers": [
        {
            "kb_id": "m.01428y",               // ← Freebase MID
            "text": "Jamaican English"
        },
        {
            "kb_id": "m.04ygk0",
            "text": "Jamaican Creole English Language"
        }
    ],
    "subgraph": {
        "tuples": [
            [4648, 430, 77418],  // ← 모두 로컬 ID
            [4648, 448, 77419],
            ...
        ],
        "entities": [...]
    }
}
```

---

## 3. ID 매핑 시스템

GNN-RAG는 **3단계 ID 시스템**을 사용합니다:

### 3.1 Freebase MID (문자열)
- **형식**: "m.XXXXXX" (예: "m.06w2sn5")
- **용도**: 원본 지식 그래프 식별자
- **예시**:
  - `"m.06w2sn5"` = Justin Bieber
  - `"m.03_r3"` = Jamaica
  - `"m.0gxnnwq"` = Jaxon Bieber

### 3.2 Global ID (정수)
- **형식**: 0 ~ 1,441,419 (entities.txt의 줄 번호)
- **생성**: `entity2id = load_dict('entities.txt')`
- **매핑**:
  ```python
  entity2id["m.06w2sn5"] = 15      # Freebase MID → Global ID
  id2entity[15] = "m.06w2sn5"       # Global ID → Freebase MID
  ```
- **특징**: 전체 지식 그래프에서 유일한 ID

### 3.3 Local ID (정수, 질문별)
- **형식**: 0 ~ max_local_entity (평균 ~1,425개, 최대 2,000개)
- **생성**: 각 질문마다 독립적인 로컬 ID 공간 생성
- **포함**: 질문 엔티티 + 서브그래프 엔티티만
- **매핑**:
  ```python
  g2l[global_id] = local_id  # Global → Local
  # 예: g2l[15] = 0, g2l[1234] = 1, g2l[5678] = 2, ...
  ```
- **특징**:
  - 질문마다 독립적 (다른 질문에서는 다른 매핑)
  - GNN 계산의 효율성을 위해 사용 (sparse graph → dense small graph)

---

## 4. 데이터 로딩 프로세스

### 4.1 Global ID 매핑 생성 (`dataset_load.py:632-658`)

```python
def load_dict(filename):
    """entities.txt를 읽어서 Freebase MID → Global ID 매핑 생성"""
    word2id = dict()
    with open(filename, encoding='utf-8') as f_in:
        for line in f_in:
            word = line.strip()
            word2id[word] = len(word2id)  # 줄 번호가 Global ID
    return word2id

# 사용:
entity2id = load_dict('data/webqsp/entities.txt')
# entity2id["m.06w2sn5"] = 15
# entity2id["m.03_r3"] = 4648
# ... (1,441,420개)

id2entity = {idx: entity for entity, idx in entity2id.items()}
# id2entity[15] = "m.06w2sn5"
# id2entity[4648] = "m.03_r3"
```

### 4.2 Local ID 매핑 생성 (`dataset_load.py:425-465`)

```python
def _build_global2local_entity_maps(self):
    """각 질문마다 Global ID → Local ID 매핑 생성"""
    global2local_entity_maps = [None] * self.num_data

    for sample_id, sample in enumerate(self.data):
        g2l = dict()  # 이 질문만의 매핑

        # 1. 질문 엔티티 추가
        for entity in sample['entities']:
            if entity not in g2l:
                g2l[entity] = len(g2l)  # Local ID = 현재 크기

        # 2. 서브그래프 엔티티 추가
        for entity in sample['subgraph']['entities']:
            if entity not in g2l:
                g2l[entity] = len(g2l)

        global2local_entity_maps[sample_id] = g2l

    return global2local_entity_maps

# 예시 결과:
# 질문 0: g2l = {15: 0, 234: 1, 567: 2, ..., 9876: 150}  (151개 엔티티)
# 질문 1: g2l = {4648: 0, 777: 1, ..., 12345: 200}       (201개 엔티티)
```

**왜 Local ID를 사용하는가?**
1. **메모리 효율**: 전체 1.4M 엔티티 대신 질문당 평균 ~1,400개만 사용
2. **계산 효율**: Dense matrix 연산 가능 (sparse graph → small dense graph)
3. **배치 처리**: 배치 내 모든 질문을 동일한 크기(max_local_entity)로 패딩

---

## 5. 정답 처리 (`dataset_load.py:203-219`)

### 5.1 정답 로딩: Freebase MID → Global ID → Local ID

```python
def _prepare_data(self):
    for next_id, sample in enumerate(self.data):
        g2l = self.global2local_entity_maps[next_id]

        # 정답 처리
        answer_list = []
        for answer in sample['answers']:
            # Step 1: Freebase MID → Global ID
            answer_kb_id = answer['kb_id']  # "m.0gxnnwq"
            answer_global_id = self.entity2id[answer_kb_id]  # 예: 123456

            answer_list.append(answer_global_id)

            # Step 2: Global ID → Local ID (존재하면)
            if answer_global_id in g2l:
                answer_local_id = g2l[answer_global_id]
                # Step 3: 정답 분포에 표시
                self.answer_dists[next_id, answer_local_id] = 1.0

        self.answer_lists[next_id] = answer_list  # Global ID로 저장
```

**중요**: `answer_lists`는 **Global ID**로 저장됩니다!

### 5.2 예시 플로우

```
질문: "what is the name of justin bieber brother"

1. JSON 파일:
   answers: [{"kb_id": "m.0gxnnwq", "text": "Jaxon Bieber"}]

2. Global ID 변환:
   entity2id["m.0gxnnwq"] = 123456

3. Local ID 변환 (서브그래프에 포함된 경우):
   g2l[123456] = 87  (이 질문의 87번째 로컬 엔티티)

4. 정답 분포 생성:
   answer_dists[question_id, 87] = 1.0

5. 정답 리스트 저장:
   answer_lists[question_id] = [123456]  ← Global ID로 저장!
```

---

## 6. GNN 추론 과정

### 6.1 입력 데이터 구조

```python
batch = valid_data.get_batch(iteration, batch_size, fact_dropout=0.0, test=True)

# 반환값:
candidate_entities[batch_size, max_local_entity]  # Local → Global ID 매핑 테이블
query_entities[batch_size, max_local_entity]      # 질문 엔티티 마스크
kb_adj_mats                                        # 서브그래프 (Local ID)
query_text                                         # 질문 텍스트 (토큰화)
seed_dist[batch_size, max_local_entity]           # 초기 확률 분포
answer_dists[batch_size, max_local_entity]        # 정답 분포 (Local ID)
answer_lists[batch_size]                          # 정답 (Global ID 리스트)
```

**핵심**: `candidate_entities`는 Local ID를 Global ID로 변환하는 룩업 테이블입니다!

```python
# 예: candidate_entities[0] = [15, 234, 567, ..., 9876, 1441420, 1441420, ...]
# Local ID 0 → Global ID 15
# Local ID 1 → Global ID 234
# ...
# Local ID 150 → Global ID 9876
# Local ID 151~ → 1441420 (패딩 값)
```

### 6.2 GNN 실행

```python
# 모델 입력: Local ID 공간
loss, extras, pred_dist, tp_list = self.model(batch[:-1])

# pred_dist: [batch_size, max_local_entity]
# 각 로컬 엔티티가 정답일 확률
```

---

## 7. 평가 프로세스 (`evaluate.py`)

### 7.1 Local ID → Global ID 변환

```python
for batch_id in range(batch_size):
    # 1. 정답 (Global ID)
    answers = batch_answers[batch_id]  # [123456, 789012, ...]

    # 2. 후보 엔티티 (Local → Global 변환)
    candidates = batch_candidates[batch_id, :].tolist()
    # candidates = [15, 234, 567, ..., 9876, 1441420, ...]

    # 3. 예측 확률 (Local ID 순서)
    probs = pred_dist[batch_id, :].tolist()
    # probs = [0.01, 0.05, 0.92, ..., 0.0001, 0.0]

    # 4. 질문 엔티티 마스크
    seed_entities = query_entities[batch_id, :].tolist()

    # 5. (Global ID, probability) 쌍 생성
    candidate2prob = []
    for local_id, (global_id, prob, is_seed) in enumerate(
        zip(candidates, probs, seed_entities)
    ):
        if is_seed == 1.0:
            continue  # 질문 엔티티 제외
        if global_id == pad_ent_id:
            continue  # 패딩 제외
        if prob < ignore_prob:
            continue  # 낮은 확률 제외

        candidate2prob.append((global_id, prob))  # Global ID 사용!

    # 6. 정답과 비교 (Global ID 기준)
    candidate2prob.sort(key=lambda x: x[1], reverse=True)
    for global_id, prob in candidate2prob:
        if global_id in answers:  # Global ID 비교
            correct += 1
```

### 7.2 F1 / Hits 계산 (`evaluate.py:25-67`)

```python
def f1_and_hits(answers, candidate2prob, id2entity, entity2name, eps=0.5):
    """
    answers: Global ID 리스트 [123456, 789012]
    candidate2prob: [(global_id, prob), ...] 확률 순 정렬
    """
    # 정답을 Freebase MID로 변환 (출력용)
    ans = [id2entity[global_id] for global_id in answers]
    # ans = ["m.0gxnnwq", "m.0123xyz"]

    # 예측을 Freebase MID로 변환
    retrieved = []
    for global_id, prob in candidate2prob:
        retrieved.append((id2entity[global_id], prob))
        # retrieved = [("m.0gxnnwq", 0.92), ("m.1234abc", 0.05), ...]

    # Hits@1: 최고 확률 예측이 정답인가?
    best_global_id = candidate2prob[0][0] if candidate2prob else -1
    hits = float(best_global_id in answers)

    # F1: 정밀도와 재현율의 조화평균
    correct = sum(1 for gid, _ in candidate2prob if gid in answers)
    precision = correct / len(retrieved) if retrieved else 0
    recall = correct / len(answers) if answers else 0
    f1 = 2 * precision * recall / (precision + recall) if correct > 0 else 0

    return precision, recall, f1, hits, em, case, retrieved, ans
```

---

## 8. 출력 파일 형식 (`.info` 파일)

평가 결과는 `checkpoint/pretrain/{experiment_name}.info` 파일에 저장됩니다:

```json
{
    "question": "what is the name of justin bieber brother",
    "answers": ["Jaxon Bieber"],           // Freebase MID → 텍스트
    "cand": [
        ["Jaxon Bieber", 0.92],            // 예측 순위 1
        ["Justin Bieber", 0.05],           // 예측 순위 2
        ...
    ],
    "precison": 1.0,
    "recall": 1.0,
    "f1": 1.0,
    "hit": 1.0,
    "em": 1.0,
    "0": {"rel_action": "people.person.sibling_s", "action": "430"},
    "1": {"rel_action": "people.siblings.sibling", "action": "431"},
    ...
}
```

---

## 9. 데이터 플로우 요약

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 데이터 로딩                                               │
│                                                              │
│  entities.txt (1.4M lines)                                  │
│    ↓                                                         │
│  entity2id: {"m.06w2sn5": 15, "m.03_r3": 4648, ...}        │
│  id2entity: {15: "m.06w2sn5", 4648: "m.03_r3", ...}        │
│                                                              │
│  JSON: {"answers": [{"kb_id": "m.0gxnnwq"}]}               │
│    ↓                                                         │
│  answer_global_id = entity2id["m.0gxnnwq"] = 123456        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Local ID 매핑 (질문별)                                    │
│                                                              │
│  질문 0의 서브그래프: [15, 234, 567, ..., 123456, ...]      │
│    ↓                                                         │
│  g2l[15] = 0, g2l[234] = 1, ..., g2l[123456] = 87          │
│                                                              │
│  candidate_entities[0] = [15, 234, ..., 123456, ...]       │
│  answer_dists[0, 87] = 1.0                                  │
│  answer_lists[0] = [123456]  ← Global ID로 저장!            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. GNN 추론 (Local ID 공간)                                  │
│                                                              │
│  입력: 로컬 서브그래프 (Local ID)                            │
│  출력: pred_dist[batch, max_local_entity]                   │
│        → 각 로컬 엔티티가 정답일 확률                        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 평가 (Global ID 기준)                                     │
│                                                              │
│  Local → Global 변환:                                        │
│    local_id=87 → candidates[87]=123456                      │
│    prob = pred_dist[87] = 0.92                              │
│                                                              │
│  비교:                                                       │
│    predicted: 123456 (확률 0.92)                            │
│    answer: 123456 ✓ 정답!                                   │
│                                                              │
│  Global → Freebase 변환 (출력):                              │
│    id2entity[123456] = "m.0gxnnwq" = "Jaxon Bieber"        │
└─────────────────────────────────────────────────────────────┘
```

---

## 10. 핵심 포인트

### 10.1 왜 3단계 ID 시스템인가?

1. **Freebase MID**: 원본 지식 그래프 표준 (문자열, 사람이 읽기 쉬움)
2. **Global ID**: 계산 효율성 (정수, 배열 인덱싱 빠름)
3. **Local ID**: 메모리/계산 효율성 (작은 밀집 그래프, 배치 처리 가능)

### 10.2 변환 체인

```
질문 로딩:     Freebase MID → Global ID
GNN 처리:      Global ID → Local ID (질문별)
GNN 출력:      Local ID 확률 분포
평가:          Local ID → Global ID → Freebase MID
```

### 10.3 메모리 이점

```
전체 그래프:   1,441,420 엔티티 × 8 bytes = 11.5 MB (per question)
로컬 그래프:   ~1,400 엔티티 × 8 bytes = 11 KB (per question)
                → 1,000배 절약!
```

### 10.4 중요한 구현 디테일

1. **`candidate_entities`**: Local→Global 룩업 테이블 (평가 필수)
2. **`answer_lists`**: Global ID로 저장 (Freebase MID 아님!)
3. **패딩 값**: `len(entity2id)` = 1,441,420 (존재하지 않는 ID)
4. **질문 엔티티 제외**: `seed_entities` 마스크 사용

---

## 11. 코드 위치 참조

| 작업 | 파일 | 함수/라인 |
|------|------|----------|
| Global ID 생성 | `dataset_load.py` | `load_dict()` (632-638) |
| Local ID 생성 | `dataset_load.py` | `_build_global2local_entity_maps()` (425-446) |
| 정답 처리 | `dataset_load.py` | `_prepare_data()` (203-219) |
| Local→Global 변환 | `evaluate.py` | `evaluate()` (188-208) |
| F1/Hits 계산 | `evaluate.py` | `f1_and_hits()` (25-67) |
| 출력 파일 생성 | `evaluate.py` | `write_info()` (106-138) |

---

## 12. 실제 예시로 이해하기

### 질문: "what is the name of justin bieber brother"

#### Step 1: 데이터 로딩
```
JSON:
  entities: [15]  ← Justin Bieber의 로컬 ID
  answers: [{"kb_id": "m.0gxnnwq"}]  ← Jaxon Bieber

entities.txt (line 16): m.06w2sn5  → entity2id["m.06w2sn5"] = 15
정답 변환: entity2id["m.0gxnnwq"] = 123456
```

#### Step 2: Local ID 매핑
```
서브그래프 엔티티 (Global ID):
  [15, 234, 567, 789, ..., 123456, ...]  (150개)

Local ID 매핑:
  g2l[15] = 0      (Justin Bieber)
  g2l[234] = 1
  g2l[567] = 2
  ...
  g2l[123456] = 87 (Jaxon Bieber) ← 정답!

candidate_entities[question_id] = [15, 234, 567, ..., 123456, ...]
answer_dists[question_id, 87] = 1.0
answer_lists[question_id] = [123456]
```

#### Step 3: GNN 추론
```
입력 서브그래프 (Local ID):
  nodes: [0, 1, 2, ..., 87, ...]
  edges: [(0, rel_430, 87), ...]  ← Justin --sibling--> Jaxon

출력 확률 분포:
  pred_dist[question_id] = [0.01, 0.02, 0.01, ..., 0.92, ...]
                            ↑                      ↑
                         local=0                local=87 ← 최고 확률!
```

#### Step 4: 평가
```
Local → Global 변환:
  local=87 → candidates[87] = 123456
  prob = pred_dist[87] = 0.92

정답 비교:
  predicted: 123456
  answer: 123456 ✓

Global → Freebase 변환:
  id2entity[123456] = "m.0gxnnwq" = "Jaxon Bieber"
```

#### 결과
```json
{
  "question": "what is the name of justin bieber brother",
  "answers": ["Jaxon Bieber"],
  "cand": [["Jaxon Bieber", 0.92], ...],
  "f1": 1.0,
  "hit": 1.0
}
```

---

이 3단계 ID 시스템 덕분에:
- **효율성**: 작은 로컬 그래프로 빠른 GNN 연산
- **정확성**: Global ID 기준으로 정확한 정답 비교
- **해석성**: Freebase MID로 사람이 이해 가능한 출력
